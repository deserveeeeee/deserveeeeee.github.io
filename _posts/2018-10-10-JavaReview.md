---
layout:     post   				    # 使用的布局（不需要改）
title:      2018-10-10-易错点记录 				# 标题
subtitle:   JavaReview #副标题
date:       2018-10-09 				# 时间
author:     Molly 						# 作者
header-img: img/review.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - JavaLearnReview
---

## java→数据类型→char

![](https://i.loli.net/2018/10/10/5bbd5cdb0fd8a.png)
这个小细节说明一下，对于char类型可以进行自增，但是如果这样写i+=1就不可以了。
![](https://i.loli.net/2018/10/10/5bbd5dcd8bb4a.png)
这个里面我定义的是double类型，它可以直接和int类型进行比较。
比如 0==0.0 可以成立。
![](https://i.loli.net/2018/10/10/5bbd61e8394f1.png)


## 十六进制转化为二进制输出的题

> 今天课上的一个十六进制转换成为二进制的题有一些不太熟悉。

题目为：求出16进制0xfa321这个数，二进制的每一个0和1，不考虑顺序。


我最开始的思路是求这个数的余，然后输出它的每一个余直到它的商为1或者0。但是随着这种思路写下来，发现进入了死循环。




### Part1：

>解决bug


这个思路的问题出于：我之前将十进制转化成为二进制的时候，使用手工计算。一般计算到最终的商剩下是0或者1就不用进行计算了。结果直接写成代码，这样就进入了**死循环**。而且会发现它的结果少了一个值。


1. 解决死循环的问题：
![](https://i.loli.net/2018/10/10/5bbd8c7a0220b.png)
当执行一次以后，SixteenNum这个变量成为了0，虽然它不满足“不等于1”这个条件，但是它满足了“等于零”这个条件。所以把或（||）改成且（&&）。这样就解决了死循环的问题。这是逻辑上没有考虑清楚的原因。


2. 解决结果少一个值的问题：
这个问题仍旧是属于逻辑上没有考虑清楚，受到手工计算思路的影响。其实“1/2 的商为0，而余为1”，而数字1仍旧需要进行一次商和余，这样结果才能完全。



### Part2：
> 优化代码：

老师补充讲解了一个更贴近计算机思考本质的方式，即使用二进制的方式去解决这个问题。
![](https://i.loli.net/2018/10/10/5bbd8e6003d74.png)

在这种解法之中，出现了一个新的运算方式：``按位与运算符&``。

使用通俗的方法解释，两个二进制的数字，它们相同位置上都是1，那么合起来的这个二进制数字该位置上才为1，其他任何情况都是0。也就是`都要为1，才为1`。（为了帮助理解，或的意思则是：`只要有一个，那么就为1`）。



所以`&1`的这个计算可以找出某个数字的最后一位二进制是0还是零。
。(也就是都必须是1才行。所以这样找最后一位的时候，如果它是1，那么就是1；否则一定是0.)
